/*
트리플 점프
 
시간 제한 메모리 제한
2초 512MB	

문제
트리플 점프는 다소 이상한 종목입니다. 대부분의 트랙&필드 종목과 마찬가지로 전투에 유용한 기술(빨리 달리기, 멀리 또는 높이 점프하기, 장애물 넘기, 창이나 망치 던지기 등)에서 유래했을 가능성이 높습니다. 트리플 점프에서는 한 번 뛰어오른 다음 세 번 연속으로 점프합니다. 거리는 첫 번째 점프의 시작부터 세 번째 점프의 “끝”까지의 거리입니다. 일반 멀리뛰기와 마찬가지로 지정된 '이륙 보드'에서 첫 번째 점프를 시작해야 하며, 이를 넘거나 미달하면 점프의 기록이 인정되지 않습니다. 또한, 착지 후 몸의 일부가 모래에 남긴 가장 먼 자국까지 거리로 계산되므로 뒤로 넘어지지 않도록 주의해야 합니다. (따라서 발로 착지한 후 엉덩이를 뒤로 젖힌 경우, 점프 시작부터 엉덩이가 땅에 닿은 곳까지의 거리가 중요합니다.)

이 문제에서는 신체 부위(발 등)가 지면에 닿은 위치가 순서대로 주어집니다. 이륙 보드는 위치 30.0에서 30.2(포함)까지 이어집니다. 시퀀스의 위치는 뒤로 돌아갔거나 뒤로 넘어졌기 때문에 증가하거나 감소할 수 있습니다. 트리플 점프는 신체 부위가 [30.0, 30.2] 간격 안에 처음 들어올 때 시작됩니다. 길이는 30.0(실제 위치가 아님)에서 실제 점프 시작보다 3보 이상 늦은 가장 작은 위치까지 측정됩니다. 이 거리는 음수가 될 수 있습니다. 간격을 터치하지 않았거나 터치한 후 3걸음도 걸지 않은 경우 거리는 0으로 계산됩니다.

입력
첫 번째 줄은 입력 데이터 세트의 개수 K이고, 그 뒤에는 각각 다음과 같은 형식의 데이터 세트 K가 이어집니다:

데이터 세트의 첫 번째 줄에는 걸음 수인 1 ≤ n ≤ 1000의 정수가 포함됩니다. 그 다음에는 n의 두 배 0.0 ≤ xi ≤ 100.0의 라인이 이어지며, xi는 i번째 스텝에서 트랙/샌드박스를 터치한 위치입니다.

출력
각 데이터 세트에 대해 “데이터 세트 x:”를 한 줄에 단독으로 출력합니다(여기서 x는 해당 번호). 그런 다음 트리플 점프의 거리를 소수점 둘째 자리로 반올림하여 출력합니다.

각 데이터 집합 뒤에는 빈 줄이 와야 합니다.

예제 입력 1 
4
11
0.0 20.5 15.7 28.3 30.1 39.7 42 48.2 50.7 46.561 52
8
1.5 19.2 28.3 30.01 38.5 45.1 51.2 60.9
6
10.7 28.3 30.3 38.1 45.2 53.87
7
15.0 30.1 38.2 45.6 56.3 40.8 27.2
예제 출력 1 
Data Set 1:
16.56

Data Set 2:
21.20

Data Set 3:
0.00

Data Set 4:
-2.80
*/

#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int K;
    cin >> K;

    for (int data_num = 1; data_num <= K; ++data_num) {
        int n;
        cin >> n;
        vector<double> steps(n);
        for (int i = 0; i < n; ++i) {
            cin >> steps[i];
        }

        int s_index = -1;
        for (int i = 0; i < n; ++i) {
            if (steps[i] >= 30.0 && steps[i] <= 30.2) {
                s_index = i;
                break;
            }
        }

        double distance = 0.0;
        if (s_index != -1 && (s_index + 3) < n) {
            int start = s_index + 3;
            double min_val = steps[start];
            for (int i = start + 1; i < n; ++i) {
                if (steps[i] < min_val) {
                    min_val = steps[i];
                }
            }
            distance = min_val - 30.0;
        }

        cout << "Data Set " << data_num << ":\n";
        cout << fixed << setprecision(2) << distance << "\n\n";
    }

    return 0;
}