/*
후프, 가위바위보 (실버) 
 
시간 제한 메모리 제한   
2초 512MB   

문제
“가위바위보"라는 게임에 대해 들어보셨을 겁니다. 소들은 “발굽, 가위, 보”라는 비슷한 게임을 좋아합니다.

“발굽 가위바위보"의 규칙은 간단합니다. 두 마리의 소가 서로 대결합니다. 두 소는 셋까지 세고 동시에 발굽, 종이, 가위 중 하나를 나타내는 제스처를 취합니다. 발굽은 가위를, 가위는 종이를(가위는 종이를 자를 수 있기 때문에), 종이는 발굽을(발굽이 종이에 베일 수 있기 때문에) 이깁니다. 예를 들어 첫 번째 소가 '발굽' 제스처를 하고 두 번째 소가 '종이' 제스처를 하면 두 번째 소가 이깁니다. 물론 두 소가 같은 제스처를 취하면 동점이 될 수도 있습니다.

농부 존은 상금 소인 베시와 '발굽, 종이, 가위바위보' 게임(1 ≤ N ≤ 100,000)을 하고 싶어합니다. 게임 전문가인 베시는 FJ의 제스처 하나하나를 미리 예측할 수 있습니다. 안타깝게도 소인 베시는 매우 게으르기도 합니다. 그 결과 같은 제스처를 여러 번 연속으로 하는 경향이 있습니다. 실제로 베시는 전체 게임 세트에서 제스처를 최대 한 번만 바꾸려고 합니다. 예를 들어, 처음 x개의 게임에서는 '발굽'을 플레이한 다음 나머지 N개의 게임에서는 '종이'로 전환할 수 있습니다.

FJ가 할 제스처의 순서가 주어졌을 때, 베시가 이길 수 있는 최대 게임 수를 구하세요.

입력
입력 파일의 첫 번째 줄에는 N이 들어 있습니다.

나머지 N 줄에는 각각 H, P 또는 S인 FJ의 제스처가 들어 있습니다.

출력
베시가 제스처를 최대 한 번만 변경할 수 있다는 가정 하에 베시가 이길 수 있는 최대 게임 수를 출력합니다.

예제 입력 1 
5
P
P
H
P
S
예제 출력 1 
4
*/

#include <bits/stdc++.h>
using namespace std;

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int N;
    cin >> N;
    vector<int> F(N+1);
    for(int i = 1; i <= N; i++){
        char c;
        cin >> c;
        if(c == 'H') F[i] = 0;
        else if(c == 'P') F[i] = 1;
        else F[i] = 2;
    }

    vector<array<int,3>> prefix_win(N+1);
    prefix_win[0] = {0,0,0};

    auto win = [&](int b, int f){
        return ( (b - f + 3) % 3 ) == 1;
    };

    for(int i = 1; i <= N; i++){
        for(int b = 0; b < 3; b++){
            prefix_win[i][b] = prefix_win[i-1][b] + (win(b, F[i]) ? 1 : 0);
        }
    }

    int ans = 0;
    for(int i = 0; i <= N; i++){
        for(int b1 = 0; b1 < 3; b1++){
            for(int b2 = 0; b2 < 3; b2++){
                int w = prefix_win[i][b1] + (prefix_win[N][b2] - prefix_win[i][b2]);
                ans = max(ans, w);
            }
        }
    }

    cout << ans << "\n";
    return 0;
}
