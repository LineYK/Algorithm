/*
박스 그림 문자
 
시간 제한   메모리 제한
1 초   1024 MB   

문제
유니코드 문자 중에는 box-drawing character(박스 그림 문자)라는 종류의 문자들이 있다. 이 문자들은 텍스트 UI에서 구역을 나누는 테두리를 그리기 위해 만들어진 것으로, 상하좌우 방향의 선들로 이루어져 있다. 박스 그림 문자의 종류는 다음과 같이 총 11가지이다.

┌ ┬ ┐ ├ ┼ ┤ └ ┴ ┘ ─ │

이 문자들을 이용하면 다음과 같이 재밌는 모양들을 만들 수 있다.



위 모양들은 모두 선이 끊어지는 곳이 없다는 특징이 있다. 예를 들어 어떤 문자가 오른쪽 방향의 선을 갖고 있다면, 그 오른쪽에는 반드시 왼쪽 방향의 선을 갖고 있는 문자가 있다. 이러한 특징을 갖는 모양들을 아름다운 모양이라고 하자. 다음은 아름다운 모양이 아닌 모양의 예시이다.



실버는 아름다운 모양 하나를 만들어 파일로 저장해 두었다. 하지만 컴퓨터가 바이러스에 감염되어 파일의 일부분이 .으로 날아가버렸다!



다행히도 .으로 대체된 부분들은 체스판처럼 배열되어 있다. 다시 말하면, i+j가 홀수일 때 i행 j열의 문자가 .으로 대체되어 있다. 자신의 작품이 망가져 좌절한 실버를 도와 모양을 복원해 보자. 단, 당신은 박스 그림 문자를 제대로 출력할 줄 모르기 때문에 각 문자들을 다음의 3 \times 3 블록으로 치환하여 입출력할 것이다.

...
.##
.#.
...
###
.#.
...
##.
.#.
.#.
.## 
.#.
.#.
###
.#.
.#.
##.
.#.
┌   ┬   ┐   ├   ┼   ┤
                     
.#.
.##
...
.#.
###
...
.#.
##.
...
...
###
...
.#.
.#.
.#.
...
...
...
└   ┴   ┘   ─   │   .
입력
첫째 줄에 실버가 만든 모양의 행 수 N과 열 수 M이 공백을 사이에 두고 주어진다. (2 \le N \le 300, 2 \le M \le 300)

이후 3N개의 줄에 걸쳐 실버가 만든 모양이 주어진다. 각 줄은 3M개의 문자로 이루어져 있으며, 각 문자는 . 또는 #이다.

출력
 3N개의 줄에 걸쳐 복원된 실버의 작품을 출력한다.

예제 입력 1 
4 4
............
.##...###...
.#..........
....#.....#.
....##...##.
....#.....#.
.#.....#....
.##...##....
.#.....#....
..........#.
...###...##.
............
예제 출력 1 
............
.##########.
.#..#.....#.
.#..#.....#.
.#..#######.
.#..#..#..#.
.#..#..#..#.
.#######..#.
.#.....#..#.
.#.....#..#.
.##########.
............
*/

#include <bits/stdc++.h>
using namespace std;

int main(){
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    int n,m;
    if(!(cin>>n>>m))return 0;
    vector<string> in(3*n);
    string line;
    for(int i=0;i<3*n;i++){
        cin>>in[i];
    }
    vector<vector<int>> mask(n, vector<int>(m, -1));
    for(int i=0;i<n;i++){
        for(int j=0;j<m;j++){
            if((i+j)%2==0){
                int bits=0;
                int bi=3*i, bj=3*j;
                // up
                if(in[bi+0][bj+1]=='#') bits |= 1;
                // right
                if(in[bi+1][bj+2]=='#') bits |= 2;
                // down
                if(in[bi+2][bj+1]=='#') bits |= 4;
                // left
                if(in[bi+1][bj+0]=='#') bits |= 8;
                mask[i][j]=bits;
            }
        }
    }
    for(int i=0;i<n;i++){
        for(int j=0;j<m;j++){
            if((i+j)%2==1){
                int bits=0;
                if(i>0 && (mask[i-1][j] & 4)) bits |= 1;
                if(j+1<m && (mask[i][j+1] & 8)) bits |= 2;
                if(i+1<n && (mask[i+1][j] & 1)) bits |= 4;
                if(j>0 && (mask[i][j-1] & 2)) bits |= 8;
                mask[i][j]=bits;
            }
        }
    }
    vector<string> out = in;
    for(int i=0;i<n;i++){
        for(int j=0;j<m;j++){
            if((i+j)%2==1){
                int bits = mask[i][j];
                int bi=3*i, bj=3*j;
                for(int di=0;di<3;di++) for(int dj=0;dj<3;dj++) out[bi+di][bj+dj] = '.';
                out[bi+1][bj+1] = '#';
                if(bits & 1) out[bi+0][bj+1] = '#';
                if(bits & 2) out[bi+1][bj+2] = '#';
                if(bits & 4) out[bi+2][bj+1] = '#';
                if(bits & 8) out[bi+1][bj+0] = '#';
            }
        }
    }
    for(auto &s: out) cout<<s<<"\n";
    return 0;
}