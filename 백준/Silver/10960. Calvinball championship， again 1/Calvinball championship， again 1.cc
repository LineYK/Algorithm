/*
캘빈볼 챔피언십, 다시 한 번 1 
 
시간 제한 메모리 제한
1 초 256 MB

문제
올해 체코에서 캘빈볼 챔피언십이 열리고 있다는 사실을 기억하세요. 
캘빈볼 게임은 고유한 이름을 가진 n명의 플레이어가 비어 있지 않은 여러 팀으로 나뉘어 진행됩니다. 
일부 플레이어는 서로를 싫어하며, 싫어하는 것은 대칭적으로 이루어집니다. 
플레이어 A가 플레이어 B를 싫어하면 B도 플레이어 A를 싫어합니다.

국제 캘빈볼 조직은 팀 선택 절차를 막판에 변경하기로 결정했습니다. 
서로 싫어하는 두 사람이 같은 팀에 있을 수 없으며, 이에 따라 팀 수는 가능한 한 작아야 합니다.

예를 들어 캘빈, 홉스, 수지, 톰, 제리, 배트맨이 게임에서 플레이하는데 
배트맨은 다른 모든 사람을 싫어하고 
톰은 제리와 홉스를 싫어하는 경우 세 팀(예: 배트맨 혼자, 
톰은 수지와 함께, 캘빈은 홉스, 제리와 함께)으로 게임을 할 수 있지만 
두 팀(배트맨, 톰, 제리는 서로 싫어하고 다른 팀에 속해야 하므로)으로는 할 수 없고 
네 팀(팀 수가 더 적을수록 가능하므로) 으로는 할 수 없습니다.

어떤 플레이어가 서로를 싫어하는지에 대한 설명이 주어지면 
플레이어를 팀으로 나눌 수 있는 몇 가지 허용되는 분할을 결정합니다(여러 팀이 존재하는 경우 임의의 분할).

입력
첫 번째 줄에는 각각 플레이어의 수와 서로 싫어하는 플레이어 쌍의 수를 
나타내는 두 개의 음이 아닌 정수 n과 m이 들어 있습니다. 
플레이어는 1부터 n까지 번호가 매겨져 있으며, 
다음 줄의 i번째 줄에는 두 개의 고유한 양의 정수 ai와 bi(1 ≤ ai, bi ≤ n)가 포함되어 있어 
플레이어 ai와 bi가 서로 싫어함을 나타냅니다.

출력
첫 번째 줄에는 플레이어가 나뉜 팀의 수를 나타내는 음이 아닌 정수 t가 포함됩니다. 
다음 t 줄의 i번째 줄에는 i번째 팀에 속한 플레이어의 수가 공백으로 구분된 목록이 포함됩니다. 
팀과 각 팀에 속한 선수는 어떤 순서로든 나열할 수 있습니다.

출력 파일은 콘테스트 인터페이스를 통해 제출해야 합니다. 
제출물에 출력 파일 중 일부가 누락된 경우, 이전 제출물(있는 경우)에서 복사하여 제출할 수 있습니다. 
따라서 출력 파일을 하나씩 제출하는 것도 가능합니다.

예제 입력 1 
6 7
1 6
2 6
3 6
4 6
5 6
5 4
2 4
예제 출력 1 
3
6
4 3
1 2 5
힌트
이 문제는 압축 파일에서 calvin1.in으로 채점합니다. (예제는 채점하지 않는다)
*/

#include <bits/stdc++.h>
using namespace std;

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);

    int n, m;
    cin >> n >> m;

    vector<int> v(n, 0);

    for(int i = 0; i < m; i++)
    {
        int a, b;
        cin >> a >> b;
        a--, b--;
        if (a < b) swap(a, b);
        v[a] |= 1 << b;
    }

    vector<int> dp(n, 0);
    int ans = 1;
    auto DFS = [&](const auto& f, int i) -> bool
    {
        if (i == n)
        {
            return true;
        }
        for (int& j = dp[i] = 1; j <= ans; j++)
        {
            bool flag = true;
            for (int k = v[i]; k; k -= k & -k)
            {
                if (dp[__lg(k & -k)] == j) flag = false;
            }
            if (flag && f(f, i + 1)) return true;
        }
        return false;
    };
    while (!DFS(DFS, 0)) ans++;

    cout << ans << '\n';
    vector<vector<int>> res(ans + 1, vector<int>(0, 0));
    for (int i = 0; i < n; i++)
    {
        res[dp[i]].push_back(i + 1);
    }
    for (int i = 1; i <= ans; i++)
    {
        for(int j : res[i])
        {
            cout << j << ' ';
        }
        cout << '\n';
    }
    return 0;
}