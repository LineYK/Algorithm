/*
계단 만들기
 
시간 제한 메모리 제한
3초 512MB

문제
꼬마 바니가 부모님으로부터 새 장난감 큐브 세트를 받았어요. 그의 세트에는 똑같은 정육면체 n개가 들어 있습니다. 바니는 즉시 이 정육면체들로 다양한 물건을 만들기 시작했습니다.

바니가 가장 최근에 만든 것은 계단입니다. 계단은 하나 이상의 큐브 탑으로 구성되며, 탑의 높이는 왼쪽에서 오른쪽으로 증가하지 않습니다. 다음 그림에서 각각 12개의 큐브가 있는 세 가지 모양을 볼 수 있습니다. 처음 두 개는 계단이고 세 번째는 계단이 아닙니다.



바니는 일부 계단의 경우 고개를 오른쪽으로 90도 돌리면 같은 계단이 보이지만 반대로 보이는 것을 발견했습니다! 그는 이러한 계단을 대칭이라고 부릅니다. 예를 들어, 위의 첫 번째 계단은 대칭이지만 두 번째 계단은 그렇지 않습니다. 공식적으로 계단은 x = y 선 위에 그림을 비췄을 때 동일한 계단(x축은 수평이고 오른쪽을 향하고 y축은 수직이고 위쪽을 향하는)을 얻을 경우에만 대칭입니다.



바니는 n개의 큐브를 모두 사용하여 대칭 계단을 만들고 싶어합니다. 어떻게 하는지 보여주세요!

입력
입력의 한 줄에는 바니가 사용할 수 있는 큐브의 개수인 정수 n이 들어 있습니다(1 ≤ n ≤ 100).

출력
n개의 정육면체가 있는 대칭 계단이 없으면 단일 정수 -1을 출력합니다.

그렇지 않으면 첫 번째 줄에 계단 그림의 행과 열의 수인 정수 m을 출력합니다 (1 ≤ m ≤ 100). 그런 다음 계단을 설명하는 줄을 m개 출력합니다. 각 줄에는 소문자 ‘o’(영문 소문자) 또는 ‘.'가 정확히 m개 포함되어야 하며, 여기서 'o'는 큐브가 있는 셀을 나타내고 ’.'는 빈 셀을 나타냅니다. 총 ‘o’ 문자는 정확히 n개여야 합니다. 왼쪽 하단의 셀에는 정육면체가 포함되어야 합니다. 솔루션이 두 개 이상 있는 경우, 그 중 하나를 출력합니다.

예제 입력 1 
3
예제 출력 1 
3
...
o..
oo.
예제 입력 2 
17
예제 출력 2 
5
o....
ooo..
oooo.
oooo.
ooooo
*/

#include <bits/stdc++.h>
using namespace std;

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    if(n == 2){
        cout << -1 << "\n";
        return 0;
    }

    vector<int> odd_parts;
    if(n % 2 == 1){
        odd_parts.push_back(n);
    } else {
        odd_parts.push_back(n - 1);
        odd_parts.push_back(1);
    }

    int r = odd_parts.size();
    int p1 = odd_parts[0];
    int m = r + (p1 - 1) / 2;

    vector<string> G(m, string(m, '.'));

    auto mark = [&](int x, int y){
        G[m - y][x - 1] = 'o';
    };

    for(int j = 1; j <= r; j++){
        int p = odd_parts[j-1];
        int arm = (p - 1) / 2;
        for(int t = 0; t <= arm; t++){
            mark(j + t, j);
            mark(j, j + t);
        }
    }

    cout << m << "\n";
    for(auto &row : G){
        cout << row << "\n";
    }
    return 0;
}
