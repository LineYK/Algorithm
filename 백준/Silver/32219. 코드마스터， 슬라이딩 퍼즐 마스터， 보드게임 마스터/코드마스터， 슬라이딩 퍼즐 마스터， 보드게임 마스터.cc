/*
코드마스터, 슬라이딩 퍼즐 마스터, 보드게임 마스터

시간 제한	메모리 제한
1 초	1024 MB

문제
진서는 진짜 유명한 코드마스터이고, 도훈이는 진짜 유명한 슬라이딩 퍼즐 마스터이다.
둘은 이제 보드게임 마스터 타이틀을 노리고 있다. 
그래서 보드게임 마스터 타이틀을 걸고 아래 규칙의 보드게임을 하기로 했다.
보드게임은 가로 방향10^5개의 행과, 세로 방향10^5개의 열로 구성된 격자판 위에서 진행된다.
(i,j)는 위에서i번째 행과 왼쪽에서j번째 열이 교차하는 칸을 나타낸다. 
예를 들어(1,10^5)은 우측상단,(10^5,1)는 좌측하단에 위치한다.


(3,3)에 위치한 말의 모습. 왼쪽(3,1),(3,2) 또는 위쪽(1,3),(2,3)로만 이동할 수 있다.

1개의 말이 격자판의(r,c) 칸에 놓여진 상태에서 게임이 시작된다.
각 턴마다 플레이어는 말을 같은 행의 왼쪽으로1칸 이상 이동시키거나, 
같은 열의 위쪽으로1칸 이상 이동시켜야 한다. 이때 말이 격자판 밖으로 나가서는 안 된다.
자신의 턴에서 더 이상 말을 이동시킬 수 있는 방법이 없다면 패배하고, 상대는 승리한다.

선공은 진서이다.
말의 처음 위치가 주어졌을 때 진서와 도훈이 중 누가 이기는지 알아내고, 
진서가 이긴다면 이기는 방법도 구해보자.

자, 이제 누가 보드게임 마스터지?

입력
첫 번째 줄에 테스트케이스의 개수t가 주어진다.

이어서t개의 각 줄에는 각 테스트케이스에서의 말의 위치를 나타내는 두 정수 r,c가 공백으로 구분되어 주어진다.

출력
각 테스트케이스마다 아래의 정보를 출력한다.

첫 번째 줄에 보드게임에서 승리하는 사람을 출력한다. 
진서가 이긴다면 jinseo, 도훈이가 이긴다면 dohoon을 출력하면 된다.

진서가 승리할 경우, 두 번째 줄에 보드게임에서 승리하기 위해 
첫 턴에서 말을 이동시킬 위치를 나타내는 두 정수r',c'를 공백으로 구분하여 출력한다. 
이는 첫 턴에(r,c)에 위치한 말을(r',c')으로 이동시킨다는 의미이다.

제한
1\le t\le 100.
1\le r,c\le 10^5.

예제 입력 1
2
1 2
2 2
예제 출력 1
jinseo
1 1
dohoon
첫 번째 테스트케이스

진서가(1,2)에 있는 말을(1,1)로 옮긴다.
도훈이는 더 이상 말을 움직일 수 없으므로 패배하고, 진서가 승리한다.

두 번째 테스트케이스

첫 번째 시나리오
진서가(2,2)에 있는 말을(1,2)로 옮긴다.
도훈이가(1,2)에 있는 말을(1,1)로 옮긴다.
진서는 더 이상 말을 움직일 수 없으므로 패배하고, 도훈이가 승리한다.
두 번째 시나리오
진서가(2,2)에 있는 말을(2,1)로 옮긴다.
도훈이가 (2,1)에 있는 말을 (1,1)로 옮긴다.
진서는 더 이상 말을 움직일 수 없으므로 패배하고, 도훈이가 승리한다.
이 외의 시나리오는 존재하지 않는다. 진서가 첫 턴에서 할 수 있는 모든 이동의 시나리오에서 패배하므로 도훈이가 게임에서 승리한다.
*/

#include <bits/stdc++.h>
using namespace std;

bool isWinningPosition(int r, int c) {
    return r != c;  // r과 c가 다르면 필승, 같으면 필패
}

pair<int,int> findWinningMove(int r, int c) {
    // 목표는 상대를 r==c인 위치로 보내는 것
    
    // 같은 행에서 이동 시도
    if (c > r) return {r, r};  // r==c인 위치로 이동
    
    // 같은 열에서 이동 시도
    if (r > c) return {c, c};  // r==c인 위치로 이동
    
    return {-1, -1}; // 여기까지 오면 안됨
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    
    int t;
    cin >> t;
    
    while (t--) {
        int r, c;
        cin >> r >> c;
        
        if (isWinningPosition(r, c)) {
            cout << "jinseo\n";
            auto move = findWinningMove(r, c);
            cout << move.first << " " << move.second << "\n";
        } else {
            cout << "dohoon\n";
        }
    }
    
    return 0;
}