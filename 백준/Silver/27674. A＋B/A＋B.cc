/*
A+B
 
시간 제한 메모리 제한
1 초 1024 MB

문제
오늘의 첫 번째 문제는 a + b처럼 간단합니다.

숫자가 주어집니다. 이 숫자들을 재배열하여 a + b의 합이 가능한 한 커지도록 두 개의 음이 아닌 정수를 만들면 됩니다.

각 숫자는 하나 이상의 숫자로 구성되어야 합니다. 선행 0은 허용되지 않지만 한 자리 숫자 0으로 구성된 숫자 0은 허용됩니다. 각 숫자는 주어진 입력 문자열에서 나타나는 횟수만큼 정확하게 사용해야 합니다.

입력
입력 파일의 첫 번째 줄에는 테스트 케이스 수를 지정하는 정수 t가 포함됩니다. 각 테스트 케이스 앞에는 빈 줄이 있습니다. 각 테스트 케이스는 하나의 숫자 문자열을 포함하는 한 줄로 구성됩니다. 문자열에 2자리 이상의 숫자가 있으면 모두 0이 아닙니다.

출력
각 테스트 케이스에 대해 얻을 수 있는 가장 큰 합계인 정수를 한 줄로 출력하세요.

서브태스크
번호 배점 제한
쉬움 1
t = 900이고 각 테스트 케이스는 정확히 3자리로 구성됩니다.

어려운 2
t = 1000이고 각 테스트 케이스의 자릿수는 2에서 16 사이입니다.

예제 입력 1 
4

001

175

21

444444
예제 출력 1 
10
76
3
44448
힌트
처음 두 테스트 케이스는 쉬운 입력 파일 a1.in에 나타날 수 있고, 나머지 두 테스트 케이스는 어려운 입력 파일 a2.in에만 나타날 수 있습니다.
각 예제 테스트 케이스에 대해 최적의 숫자 배열이 하나씩 있습니다: 10+0, 71+5, 1+2, 44444+4.
*/

#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    int t;
    cin >> t;

    while(t--){
        string s;
        cin >> s;
        
        sort(s.begin(), s.end(), greater<char>());
        
        string a_str = s.substr(0, s.size()-1);
        string b_str = s.substr(s.size()-1);
        
        long long a = stoll(a_str);
        long long b = stoll(b_str);
        
        cout << a + b << "\n";
    }
    
    return 0;
}
