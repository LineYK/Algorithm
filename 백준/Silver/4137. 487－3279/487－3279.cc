/*
487-3279 
 
시간 제한 메모리 제한
1초 128MB

문제
기업들은 기억에 남는 전화번호를 원합니다. 전화번호를 기억에 남게 만드는 한 가지 방법은 기억에 남는 단어나 문구의 철자를 사용하는 것입니다. 예를 들어, 기억에 남는 TUT-GLOP으로 전화를 걸어 워털루 대학교에 전화를 걸 수 있습니다. 때로는 번호의 일부만 단어의 철자로 사용되기도 합니다. 오늘 밤 호텔로 돌아가면 310-GINO를 눌러 Gino's에서 피자를 주문할 수 있습니다. 전화번호를 기억하기 쉽게 만드는 또 다른 방법은 숫자를 기억하기 쉬운 방식으로 그룹화하는 것입니다. 피자헛에서 피자를 주문하려면 3-10-10-10으로 전화를 걸어 3-10-10-10을 누르면 됩니다.

전화번호의 표준 형식은 세 번째 자리와 네 번째 자리 사이에 하이픈이 있는 십진수 7자리입니다(예: 888-1200). 휴대폰의 키패드는 다음과 같이 문자와 숫자의 매핑을 제공합니다:

A, B, C는 2
D, E, F는 3
G, H, I는 4
J, K, L은 5
M, N, O는 6
P, R, S는 7
T, U, V는 8
W, X, Y는 9
Q 또는 Z는 매핑되지 않으며 필요에 따라 추가 및 제거할 수 있습니다. TUT-GLOP의 표준 형식은 888-4567, 310-GINO의 표준 형식은 310-4466, 3-10-10-10의 표준 형식은 310-1010입니다.

두 전화번호의 표준 형식이 같으면 두 전화번호는 동일합니다. (같은 번호로 전화를 겁니다.)

회사에서 지역 업체의 전화번호 디렉토리를 작성하고 있습니다. 품질 관리 프로세스의 일환으로 전화번호부에 있는 두 개(또는 그 이상의) 업체 전화번호가 동일한지 확인하려고 합니다.

입력
입력은 하나의 케이스로 구성됩니다. 입력의 첫 번째 줄은 전화번호부에 있는 전화번호의 수(최대 100,000개)를 한 줄에 양의 정수로만 지정합니다. 나머지 줄은 디렉토리에 있는 전화번호를 한 줄에 한 번호씩만 나열합니다. 각 전화번호는 십진수, 대문자(Q 및 Z 제외) 및 하이픈으로 구성된 문자열로 구성됩니다. 문자열의 문자 중 정확히 7개의 문자가 숫자 또는 문자로 구성됩니다.

출력
어떤 형태로든 두 번 이상 나타나는 각 전화번호에 대해 한 줄의 출력을 생성합니다. 한 줄에는 표준 형식의 전화번호와 공백, 그리고 전화번호가 전화번호부에 나타나는 횟수가 나와야 합니다. 전화번호별로 사전 오름차순으로 출력 줄을 정렬합니다. 입력에 중복이 없는 경우 해당 줄을 인쇄합니다: 중복 없음.

예제 입력 1 
12
4873279
ITS-EASY
888-4567
3-10-10-10
888-GLOP
TUT-GLOP
967-11-11
310-GINO
F101010
888-1200
-4-8-7-3-2-7-9-
487-3279
예제 출력 1 
310-1010 2
487-3279 4
888-4567 3
*/

#include <bits/stdc++.h>
using namespace std;

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    // 문자→숫자 매핑 테이블
    char mp[26];
    // A,B,C→2
    mp['A'-'A'] = mp['B'-'A'] = mp['C'-'A'] = '2';
    // D,E,F→3
    mp['D'-'A'] = mp['E'-'A'] = mp['F'-'A'] = '3';
    // G,H,I→4
    mp['G'-'A'] = mp['H'-'A'] = mp['I'-'A'] = '4';
    // J,K,L→5
    mp['J'-'A'] = mp['K'-'A'] = mp['L'-'A'] = '5';
    // M,N,O→6
    mp['M'-'A'] = mp['N'-'A'] = mp['O'-'A'] = '6';
    // P,R,S→7  (Q 없음)
    mp['P'-'A'] = mp['R'-'A'] = mp['S'-'A'] = '7';
    // T,U,V→8
    mp['T'-'A'] = mp['U'-'A'] = mp['V'-'A'] = '8';
    // W,X,Y→9  (Z 없음)
    mp['W'-'A'] = mp['X'-'A'] = mp['Y'-'A'] = '9';

    int n;
    cin >> n;
    unordered_map<string,int> freq;
    freq.reserve(n*2); // n개 정도의 입력을 예상하고 미리 공간 확보

    string s;
    for(int i = 0; i < n; i++){
        cin >> s;
        string digits;
        digits.reserve(7); // 표준 번호는 7자리 숫자
        for(char c : s){
            // 7개의 숫자를 이미 완성했다면 더 이상 처리하지 않음
            if (digits.size() == 7) {
                break;
            }

            if (c == '-') { // 하이픈은 무시
                continue;
            }

            if (c >= '0' && c <= '9'){ // 숫자인 경우
                digits.push_back(c);
            } else if (c >= 'A' && c <= 'Y') { // 대문자인 경우 (문제 조건상 Q, Z 제외 A-Y 범위)                                             
                if (c == 'Q' || c == 'Z') {   // Q 또는 Z는 매핑되지 않으므로 무시
                    continue;
                } else {
                    // Q, Z가 아닌 다른 대문자는 매핑 테이블을 사용해 변환
                    digits.push_back(mp[c - 'A']);
                }
            }
  
        }
        
        
        string key = digits.substr(0,3) + "-" + digits.substr(3,4);
        freq[key]++;
    }

    vector<pair<string,int>> ans;
    for(auto &p : freq){
        if (p.second > 1)
            ans.emplace_back(p.first, p.second);
    }

    if (ans.empty()){
        cout << "No duplicates.\n";
    } else {
        sort(ans.begin(), ans.end(),
             [](auto &a, auto &b){ return a.first < b.first; });
        for(auto &p : ans){
            cout << p.first << ' ' << p.second << "\n";
        }
    }

    return 0;
}