/*
현대 미술

시간 제한 메모리 제한
1 초 1024 MB

문제
한 신예 아티스트가 체크무늬 패턴을 만드는 독특한 방법을 가지고 있습니다. 처음에는 완전히 검은색인 M-by-N 캔버스를 사용하는 것이 아이디어입니다. 그런 다음 아티스트는 행이나 열을 반복해서 선택하고 행이나 열을 따라 매직 브러시를 실행합니다. 브러시는 행 또는 열의 각 셀 색상을 검정색에서 금색으로 또는 금색에서 검정색으로 변경합니다.

아티스트의 선택이 주어지면, 여러분의 임무는 이러한 선택에 따라 결정된 패턴에 얼마나 많은 금이 나타나는지 결정하는 것입니다.

입력
첫 번째 입력 줄은 양의 정수 M. 두 번째 입력 줄은 양의 정수 N. 세 번째 입력 줄은 양의 정수 K. 나머지 입력 줄은 아티스트의 선택이 주어지는 K줄입니다. 각 줄은 R 뒤에 공백 한 개와 행 번호인 정수가 오거나, C 뒤에 공백 한 개와 열 번호인 정수가 올 수 있습니다. 행은 위에서 아래로 1부터 M까지 번호가 매겨지고, 열은 왼쪽에서 오른쪽으로 1부터 N까지 번호가 매겨집니다.

출력
아티스트가 선택한 패턴에서 금색인 셀의 수와 같은 음수가 아닌 정수 하나를 출력합니다.

제한
1 ≤ M, N ≤ 5 000 000
MN ≤ 5 000 000
K ≤ 1 000 000
최대 5 000 000 셀, 아티스트가 선택한 최대 1,000,000.
예제 입력 1
3
3
2
R 1
C 1
예제 출력 1
4
첫 번째 행을 따라 브러시를 실행하면 캔버스는 다음과 같이 보입니다:

GGG
BBB
BBB
그런 다음 첫 번째 열을 따라 브러시를 실행하면 아티스트의 선택에 따라 결정된 최종 패턴에서 네 개의 셀이 금색으로 표시됩니다:

BGG
GBB
GBB
예제 입력 2
4
5
7
R 3
C 1
C 2
R 2
R 2
C 1
R 4
예제 출력 2
10
아티스트가 선택한 최종 패턴에서 10개의 셀은 금색입니다:

BGBBB
BGBBB
GBGBG
GBGBG
*/

#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int M, N, K;
    cin >> M >> N >> K;

    vector<char> row(M, 0), col(N, 0);
    for (int it = 0; it < K; it++) {
        char type;
        int idx;
        cin >> type >> idx;
        if (type == 'R') {
            row[idx - 1] ^= 1;
        }
        else {
            col[idx - 1] ^= 1;
        }
    }

    long long R1 = 0, C1 = 0;
    for (char b : row) if (b) R1++;
    for (char b : col) if (b) C1++;

    long long gold = R1 * (long long)(N - C1) + (long long)(M - R1) * C1;
    cout << gold << "\n";
    return 0;
}
