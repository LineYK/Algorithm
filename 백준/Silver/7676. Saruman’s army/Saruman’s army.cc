/*
사루만의 군대
 
시간 제한 메모리 제한
1 초 128 MB

문제
하얀 사루만은 군대를 이끌고 이센가드에서 헬름의 심연까지 직진해야 합니다. 
사루만은 자신의 군대를 추적하기 위해 팔란티르라고 하는 투시석을 군대에게 나눠줍니다. 
각 팔란티어는 최대 유효 사거리가 R 단위이며, 
군대의 일부 부대가 반드시 휴대해야 합니다(즉, 팔란티어는 공중에 '자유 부양'할 수 없습니다). 
사루만이 미들 어스를 장악하는 데 필요한 최소 팔란티어 수를 결정하여 
사루만의 각 하수인이 일부 팔란티어의 R 단위 내에 있도록 하세요.

입력
입력 테스트 파일에는 여러 개의 케이스가 포함됩니다. 
각 테스트 케이스는 모든 팔란티르의 최대 유효 범위인 정수 R(여기서 0 ≤ R ≤ 1000)과 사루만의 군대 병력 수인 정수 n(여기서 1 ≤ n ≤ 1000)을 포함하는 한 줄로 시작됩니다. 다음 줄에는 각 부대의 위치 x1, ..., xn을 나타내는 정수가 n 개 들어 있습니다(여기서 0 ≤ xi ≤ 1000). 파일 끝에는 R = n = -1인 테스트 케이스가 표시됩니다.

출력
각 테스트 케이스에 대해 필요한 최소 팔란티르 수를 나타내는 단일 정수를 출력합니다.

예제 입력 1 
0 3
10 20 20
10 7
70 30 1 7 15 20 50
-1 -1
예제 출력 1 
2
4
힌트
첫 번째 테스트 케이스에서 사루만은 10번과 20번 위치에 팔란티어를 배치할 수 있습니다. 여기서 사거리가 0인 팔란티어 한 개로 20번 위치에 있는 두 병력을 모두 커버할 수 있다는 점에 유의하세요.

두 번째 테스트 사례에서 사루만은 7번 위치(1, 7, 15번 위치의 병력을 엄호), 20번 위치(20번과 30번 위치 엄호), 50번 위치, 70번 위치에 팔란티어를 배치할 수 있습니다. 여기서 팔란티어는 부대에 분배되어야 하며 “자유롭게 떠다니는” 것은 허용되지 않습니다. 따라서 사루만은 위치 60에 팔란티어를 배치하여 위치 50과 70에 있는 부대를 엄호할 수 없습니다.
*/

#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    while (true) {
        int R, n;
        cin >> R >> n;
        if (R == -1 && n == -1) break;

        vector<int> positions(n);
        for (int i = 0; i < n; i++) {
            cin >> positions[i];
        }

        sort(positions.begin(), positions.end());

        int palantirs = 0;
        int i = 0;

        while (i < n) {
            palantirs++;
            int loc = positions[i] + R;
            while (i < n && positions[i] <= loc) {
                i++;
            }
            loc = positions[i - 1] + R;
            while (i < n && positions[i] <= loc) {
                i++;
            }
        }

        cout << palantirs << "\n";
    }
    return 0;
}
