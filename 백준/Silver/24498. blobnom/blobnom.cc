/*
blobnom
 
시간 제한	메모리 제한
1 초	1024 MB

문제
블롭들은 심심해서 서로를 이용해 N개의 탑을 만들었다. 각 탑의 높이는 그 탑에 있는 블롭의 수와 같다.

여러분은 다음 행동을 0회 이상 할 수 있다.

1. 처음과 마지막이 아닌 탑 중 하나를 선택한다. 단, 선택한 탑과 인접한 두 탑의 높이가 모두 1 이상이어야 한다.
2. 선택한 탑과 인접한 두 탑에 있는 블롭을 한 마리씩 각각 땅에 내려놓는다. 즉, 인접한 두 탑의 높이가 모두 1만큼 감소한다.
3. 땅에 내려놓은 두 마리의 블롭 중 하나의 블롭만 1.에서 선택한 탑에 쌓는다. 즉, 선택한 탑의 높이가 1만큼 증가한다.

이 과정에서 이전에 인접하지 않았던 두 탑이 새롭게 인접하게 되지는 않는다. 
채완이를 위해 만들 수 있는 가장 높은 탑의 높이를 구해 주자.

입력
첫째 줄에 탑의 개수 
N이 주어진다.

둘째 줄에 각 탑의 높이 
A_1, A_2, ..., A_N이 공백으로 구분되어 주어진다.

출력
문제의 정답을 출력한다.

제한
1 <= N <= 10^6 
1 <= A_i <= 10^9 (1 <= i <= N)

예제 입력 1 
4
1 3 2 2
예제 출력 1 
4
아래와 같은 과정을 거치면 가장 높은 탑의 높이가 
4가 된다.

[1, 3, \underline{2}, 2] 
 
[1, 2, \underline{3}, 1] 
 
[1, 1, 4, 0] 

밑줄 친 수는 각 과정에서 선택한 탑의 블롭 수이다.

가장 높은 블롭 탑의 높이를 4로 만드는 다른 방법이 있을 수 있음에 유의하라.

예제 입력 2 
5
2 4 3 5 5
예제 출력 2 
8
*/

#include <bits/stdc++.h>

using namespace std;

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);

    int N;
    cin >> N;

    vector<int> A(N);
    for (int i = 0; i < N; i++)
    {
        cin >> A[i];
    }

    int ans = INT_MIN;

    for (int i = 1; i < N - 1; i++)
    {
        int target = min(A[i - 1], A[i + 1]) + A[i];
        ans = max(ans, target);
    }

    ans = max(max(ans, A[0]), A[N - 1]);

    cout << ans;

    return 0;
}
