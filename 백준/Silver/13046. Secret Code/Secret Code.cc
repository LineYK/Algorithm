/*
비밀 코드
 
시간 제한    메모리 제한
2 초    512 MB

문제
현재 마티는 과거에 있으며, 1985년으로 돌아가고 싶어합니다. 그는 이미 부모님이 서로 사랑에 빠지게 만들었고, 플루토늄을 발견했습니다. 남은 일은 시간 기계를 활성화하고 시간 여행을 시작하는 것입니다. 그러나 마티에게는 문제가 있습니다. 시간 기계를 활성화하려면 비밀 코드를 입력해야 합니다. 비밀 코드는 도크만 알고 있습니다. 마티가 알고 있는 것은 코드가 여러 가지 다른 문자로 구성되어 있다는 것과 코드의 길이입니다. 마티는 도크를 기다리며 코드를 추측하고 다양한 문자 조합을 입력하고 있습니다.

이제 닥터가 돌아와 코드를 입력했습니다. 마티는 자신이 올바른 코드에 얼마나 가까웠는지 알고 싶어합니다. 마티가 코드를 입력한 각 시도마다, 코드에서 올바른 위치에 있는 올바른 문자의 수와, 올바른 문자이지만 잘못된 위치에 있는 문자의 수를 찾아주세요.

입력
첫 번째 줄에는 s — 올바른 비밀 코드가 포함되어 있습니다. 코드는 영어 알파벳의 대문자와 숫자로 구성되어 있습니다. 코드 내 모든 문자는 서로 다릅니다.

두 번째 줄에는 정수 n (1 ≤ n ≤ 10⁵) — 마티의 시도 횟수가 포함되어 있습니다.

다음 n개의 각 줄에는 마티의 시도 정보가 포함됩니다. 각 줄에는 s와 동일한 길이의 코드가 포함되며, 이 코드는 영어 알파벳의 대문자와 숫자로 구성됩니다. 한 코드 내의 모든 문자는 서로 다릅니다.

출력
마티의 각 시도마다 두 개의 정수 a와 b를 출력합니다: a는 올바른 위치에 있는 올바른 문자 수, b는 올바른 위치에 있지 않지만 올바른 문자 수입니다.
 
예제 입력 1 
BACKTO1985
3
BACKTO1958
BACKON1985
TOYEAR1985
예제 출력 1 
8 2
8 1
4 3
*/

#include <bits/stdc++.h>
using namespace std;

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    string s;
    cin >> s;
    int n;
    cin >> n;

    int L = s.size();
    unordered_map<char, int> pos;
    pos.reserve(L);
    for(int i = 0; i < L; i++){
        pos[s[i]] = i;
    }

    while(n--){
        string t;
        cin >> t;
        int a = 0, b = 0;
        for(int i = 0; i < L; i++){
            if(t[i] == s[i]) {
                a++;
            }
        }
        for(int i = 0; i < L; i++){
            if(t[i] != s[i] && pos.count(t[i])){
                b++;
            }
        }
        cout << a << " " << b << "\n";
    }

    return 0;
}
