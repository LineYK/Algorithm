/*
번개 강의
 
시간 제한    메모리 제한    
1 초    128 MB    

문제
제우스는 불안하게 손을 비틀며 말했다. “나는 곧 열릴 신들의 축제에서 토르와 결투를 하기로 약속했기 때문에 당신에게 왔습니다. 당신은 싸움에 능숙한 라덴이니까, 나를 도와주셔야 합니다!”

라이덴은 모자 가장자리 아래에서 얇게 미소지으며 대답했다. “당신처럼 강력한 신에게 어떤 도움을 줄 수 있겠는가? 당신의 번개는 전설의 소재가 되니까!” 제우스는 아래를 내려다보며 말을 더듬었다. “나는. . . 나는 운이 좋았을 뿐이야. 번개가 어떻게 작동하는지 모르겠어요. 때로는 적을 탄화된 잔해로 만들지만, 다른 때는. . . 이상한 일이 일어나요. 아폴로가 시인들에게 제 비밀을 숨기도록 설득하지 않았다면, 저는 웃음거리가 되었을 거예요.”

라이덴은 눈썹을 치켜세우며 물었다. “이상한 일?” 제우스는 고개를 들어 깊은 숨을 쉬었다. “때로는 그냥 사라져버려요. 다른 때는 말려서… 토끼로 변해요.” 라이덴은 크게 웃으며 말했다. “토끼라니! 그건 정말 대단한 기운이네요.” 제우스가 얼굴을 붉히자, 라이덴은 손을 들어 말했습니다. “걱정 마세요, 도와드릴게요.”

라이덴은 계속 설명했다. “번개는 기의 회전 순서, 즉 인간들이 ‘지그재그’라고 부르는 것입니다. 각 회전은 정수 진폭을 가지고—”  

“그 정도는 알아요.” 제우스가 말을 끊었다. “하지만 번개는 생동감 있고 예측할 수 없어요. 번개가 치면 진폭이 모두 무작위로 변해요!”  

“번쩍이는 모든 것이 불꽃은 아니에요. 번개를 주의 깊게 관찰하면 ‘사이클’을 거치며 각 사이클마다 한 번의 회전씩 짧아집니다. 번개가 사이클을 거칠 때, 각 후속 회전의 진폭은 이전 사이클의 끝에서 전임자의 진폭만큼 감소하며, 첫 번째 회전은 사라집니다. 만약 번개가 모든 진폭이 0이 되는 상태에 도달하면, 이전 사이클의 수에 비례하는 힘으로 목표물을 공격합니다. 당신의 ‘이상한 현상’은 번개가 단일 비제로 진폭으로 사이클링될 때만 발생합니다. 양의 진폭은 단순히 폐열로 소멸하지만, 음의 진폭은 이상한 저엔트로피 상태를 생성합니다. 당신이 전투 중 뛰어다니는 것을 본 것은 후자입니다.”

제우스가 당황하지 않도록, 번개가 수렴할 경우 그 힘이 얼마나 될지 예측하거나, 분산될 경우 어떻게 될지 예측하는 프로그램을 작성하세요.

입력
입력의 첫 번째 줄에는 번개가 몇 개 따라오는지 나타내는 단일 양의 정수 N이 있습니다. 각 번개는 정수 M(0 < M ≤ 20)로 시작하는 줄로 지정되며, 그 다음에는 각 연속된 피봇의 초기 진폭을 나타내는 M개의 공백으로 구분된 정수가 따라옵니다. 초기 진폭의 절대값은 1000을 초과하지 않습니다.

출력
수렴하는 각 번개에 대해, 수렴하기 전에 만난 사이클 수 P를 나타내는 문자 “z”를 P번 반복한 후, 문자열 “ap!”을 출력합니다(모든 0 사이클은 P에 포함되지 않습니다).

수렴하지 않는 각 번개에 대해, 최종 진폭이 양수라면 “*fizzle*”, 음수라면 “*bunny*”를 출력합니다.

예제 입력 1 
4
2 1 1
5 1 3 6 10 15
5 1 2 4 8 16
2 1 0
예제 출력 1 
zap!
zzzap!
*fizzle*
*bunny*
*/

#include <bits/stdc++.h>
using namespace std;

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int N;
    cin >> N;
    while(N--){
        int M;
        cin >> M;
        vector<long long> a(M);
        for(int i = 0; i < M; i++) {
            cin >> a[i];
        }

        int cycles = 0;
        while (true) {
            bool allZero = true;
            for (auto &v : a) {
                if (v != 0) { allZero = false; break; }
            }
            if (allZero) {
                cout << string(cycles, 'z') << "ap!\n";
                break;
            }

            if (a.size() == 1) {
                if (a[0] > 0) cout << "*fizzle*\n";
                else          cout << "*bunny*\n";
                break;
            }

            vector<long long> b(a.size() - 1);
            for (int i = 0; i + 1 < (int)a.size(); i++) {
                b[i] = a[i+1] - a[i];
            }
            a.swap(b);
            cycles++;
        }
    }

    return 0;
}
