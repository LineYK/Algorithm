/*
도로변 최적화
 
시간 제한 메모리 제한
1초 256MB   

문제
G 지방의 일부 마을은 도로로 연결되어 있으며 도로는 항상 양방향으로 진행됩니다. 
도로망을 지원하기 위한 예산이 부족하여 최소한의 도로만 남겨두기로 결정했습니다. 
그러나 현재 A 마을에서 B 마을로 갈 수 있다면, 감축 후에도 이 가능성은 유지되어야 합니다.

남아 있어야 하는 최소 도로 수를 정의하는 데 도움을 주세요.

입력
입력 파일의 첫 줄에는 테스트 횟수인 단일 정수 T(1 \le T \le 50\,000)가 포함됩니다. 그 다음에는 T 테스트에 대한 설명이 이어집니다.

테스트 번호 t의 첫 번째 줄에는 단일 정수 N_t --- 마을 수(1 \le N_t \le 200)가 포함됩니다.

다음 N_t 줄에는 N_t 개의 정수가 포함되며, 각 정수는 0 또는 1입니다. 숫자 i가 있는 선의 j번째 위치에 0이 있으면 다른 마을을 통과해도 마을 i에서 마을 j에 도달할 수 없고, 1이면 통로가 있는 것입니다. 한 마을에서 같은 마을로 가는 통로가 있다고 가정하므로, 째 위치의 째 줄에는 항상 1이 있습니다(1 \le i \le N_t).

모든 테스트에서 N_t^2의 합이 50\,000보다 크지 않음을 보장합니다.

출력
각 테스트에 대해 유지해야 하는 최소 도로 수를 별도의 줄에 하나의 정수로 출력합니다.

예제 입력 1 
1
1
1
예제 출력 1 
0
예제 입력 2 
2
4
1 1 1 1
1 1 1 1
1 1 1 1
1 1 1 1
7
1 1 1 0 0 0 0
1 1 1 0 0 0 0
1 1 1 0 0 0 0
0 0 0 1 1 0 1
0 0 0 1 1 0 1
0 0 0 0 0 1 0
0 0 0 1 1 0 1
예제 출력 2 
3
4
*/

#include <bits/stdc++.h>
using namespace std;

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int T;
    cin >> T;
    while(T--){
        int N;
        cin >> N;
        vector<vector<int>> a(N, vector<int>(N));
        for(int i = 0; i < N; i++){
            for(int j = 0; j < N; j++){
                cin >> a[i][j];
            }
        }

        vector<bool> vis(N,false);
        int answer = 0;
        for(int i = 0; i < N; i++){
            if(vis[i]) continue;
            int sz = 0;
            for(int j = 0; j < N; j++){
                if(a[i][j]){
                    sz++;
                    vis[j] = true;
                }
            }
            answer += (sz - 1);
        }

        cout << answer << "\n";
    }
    return 0;
}